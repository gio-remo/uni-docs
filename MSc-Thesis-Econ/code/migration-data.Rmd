---
title: "Code"
output: github_document
---

# Net-Migration Data, cell level

## Niva (2023) - World’s human migration patterns in 2000–2019 unveiled by high-resolution data

Source: https://doi.org/10.1038/s41562-023-01689-4

Code References:

- (Context) Spatial Data Science: With Applications in R: https://doi.org/10.1201/9780429459016
- (Code) R as GIS for Economists: https://tmieno2.github.io/R-as-GIS-for-Economists-Quarto/

Let's import the dataset produced by Niva (2023):

- Data: https://zenodo.org/records/7997134
- Gridded global Net-Migration (per 1000 people)
- Yearly 2000-2019 (20 years)
- High-resolution, 5 arc-min / 0.083° https://www.inchcalculator.com/convert/degree-to-arcminute/

**RESAMPLING**! Climate data have resolution of 6 arcmin (0.1°). Therefore I need to resample migration data from 5 arcmin (0.083°) to 6 arcmin! 

```{r}
library(terra)
library(tidyr)
library(ggplot2)
library(dplyr)

# Import Net-Migration data, 2000-2019 yearly (20 layers)
filepath_raster_netMgr_2000_2019_annual <- "../data/raster_netMgr_2000_2019_annual.tif"
r_original <- rast(filepath_raster_netMgr_2000_2019_annual)

r_original # 2160 * 4320 * 20 years
```

**RESAMPLING!**

```{r}
# Template at 0.1° (6 arcmin) resolution
r_template <- rast(ext(r_original), resolution = 0.1, crs = crs(r_original))

# Resample to 0.1°
r_resampled <- resample(r_original, r_template, method = "bilinear")

# Convert to data.frame
df_netMgr_2000_2019_annual <- as.data.frame(r_resampled, xy = TRUE, na.rm = TRUE)
```

ORIGINAL raster

```{r}
ext(r_original)
```

```{r}
res(r_original)
```

RESAMPLED raster

```{r}
ext(r_resampled)
```

```{r}
res(r_resampled)
```

Now we can start working on the dataset.

```{r}
# From wide (22 columns) to long
df_netMgr_2000_2019_annual_long <- pivot_longer(df_netMgr_2000_2019_annual, -c(x, y), names_to = "layer", values_to = "value") # 31.375.980 obs
colnames(df_netMgr_2000_2019_annual_long) <- c("x", "y", "year", "netmgr")

summary(df_netMgr_2000_2019_annual_long$netmgr)
```

```{r}
df_netMgr_2000_2019_annual_long[df_netMgr_2000_2019_annual_long$netmgr == 0, ]
```


Many cells (4.2 mln) have value 0. This would imply that natural birth and death rate perfectly match. Leaving these 0 in the dataset alters the analysis, and as a perfect match of the demographic rates seems rather a residual case (total observations: 31 mln).

I've decided to remove the observations with value 0. Here I plot these observations, they mostly cover Greenland.

```{r}
# Zeros
df_zeros <- df_netMgr_2000_2019_annual_long[df_netMgr_2000_2019_annual_long$netmgr == 0,] # Length 6,7mln observations

avg_zeros <- df_zeros %>%
  group_by(x, y) %>%
  summarise(m = mean(netmgr, na.rm = TRUE))

ggplot() +
  geom_tile(data = avg_zeros, aes(x, y), fill = "red") +
  coord_fixed()
```

Therefore, let's remove observations with 0.

```{r}
# Remove 0s
df_netMgr_2000_2019_annual_long <- df_netMgr_2000_2019_annual_long[df_netMgr_2000_2019_annual_long$netmgr != 0,] # From 45mln to 38 mln observation

summary(df_netMgr_2000_2019_annual_long$netmgr)
```


Let's proceed cleaning our dataset, it's time for outliers. I remove outliers at 0.01 and 0.99 percentiles.

```{r}
p <- quantile(df_netMgr_2000_2019_annual_long$netmgr, probs = c(0.01, 0.99))

# Filter out outliers (1st, 99th percentile)
df_netMgr_2000_2019_annual_long <- df_netMgr_2000_2019_annual_long[
  df_netMgr_2000_2019_annual_long$netmgr >= p[1] &
  df_netMgr_2000_2019_annual_long$netmgr <= p[2], ] # From 38mln to 37mln

summary(df_netMgr_2000_2019_annual_long$netmgr)
```


Our Net-Migration dataset is ready. Let's plot the distribution.

Most observations have values very close to 0. For instance, a value of 0.02, considering values are the ratio between net migration and 1,000 people, means that for every 1,000 residents, there was a net gain of only 0.02 people, equivalent to just 2 individuals per 100,000 people. Instead, a value of 1 means that for every 1,000 residents, there was a net gain of 1 person.

These are RATIOs. In a region with a population of 100,000:
- A value of 0.2 would imply a net migration of 20 people (0.2/1000 * 100k)
- A value of 1 would imply a net migration of 100 people (1/1000 * 100k)

```{r}
pp <- quantile(df_netMgr_2000_2019_annual_long$netmgr, probs = c(0.25, 0.5, 0.75))

ggplot(data = df_netMgr_2000_2019_annual_long, aes(netmgr)) +
  geom_histogram(binwidth = 0.01) +
  xlim(-3.5, 2.5) +
    geom_vline(xintercept = pp[1], color="red", alpha=0.5, linetype="dotted") +
  geom_vline(xintercept = pp[2], color="red", alpha=0.5, linetype="dotted") +
  geom_vline(xintercept = pp[3], color="red", alpha=0.5, linetype="dotted") +
  annotate("text", x = pp[1], y = 10000, label = "25th", vjust = -2, color = "red") +
  annotate("text", x = pp[2], y = 10000, label = "50th", vjust = -2, color = "red") +
  annotate("text", x = pp[3], y = 10000, label = "75th", vjust = -2, color = "red")
```


Single observations (cell, year) with POSITIVE Net-Migration = 12 mln

```{r}
df_netMgr_2000_2019_annual_long[df_netMgr_2000_2019_annual_long$netmgr > 0, ]
```

Single observations (cell, year) with NEGATIVE Net-Migration = 13 mln

```{r}
df_netMgr_2000_2019_annual_long[df_netMgr_2000_2019_annual_long$netmgr < 0, ]
```

It's time to merge Income and Net-Migration data.

1. Both datasets use the same coordinate/projection system: EPSG:4326 (WGS84) https://epsg.io/4326. This is reassuring, as allows us to spatially merge the features of the two datasets without having to resample.

2. After RESAMPLING, both datasets have the same resolution: 0.1° / 6 arc-min https://www.inchcalculator.com/convert/degree-to-arcminute/

Let's plot them together.

```{r}
# Import clean version of income data
gdp <- read.csv("../data/income-gdp-quarter.csv")

# Net-Migration data for 1 year, to be able to plot
netmgr_1y <- df_netMgr_2000_2019_annual_long[df_netMgr_2000_2019_annual_long$year == 2000,]

library(patchwork)

p1 <- ggplot() +
  geom_raster(data = gdp, aes(x = x, y = y, fill = mean_gdp)) +
  coord_fixed() +
  scale_fill_viridis_c(name = "GDP per capita")


p2 <- ggplot() + 
  geom_raster(data = netmgr_1y, aes(x = x, y = y, fill = netmgr)) +
  coord_fixed() +
  scale_fill_viridis_b(name = "Net-Migr/1000pp", limits = c(-50, 50), breaks = seq(-50, 50, 25))

p1 + p2 + plot_layout(ncol = 1)
```

```{r}
# Function to filter
filter_continent <- function(grid, lon_min, lon_max, lat_min, lat_max) {
  subset(grid, x >= lon_min & x <= lon_max & y >= lat_min & y <= lat_max)
}
```

Let's overlap them to check whether they're actually using the same grid after resampling!

First, let's subset our global dataset and select a small area, north-east Italy.

```{r}
# Subset the area of interest
gdp_subset <- filter_continent(gdp, lon_min = 10, lon_max = 15, lat_min = 44, lat_max = 49)
netmgr_subset <- filter_continent(df_netMgr_2000_2019_annual_long, lon_min = 10, lon_max = 15, lat_min = 44, lat_max = 49)

p3 <- ggplot() +
  geom_tile(data = gdp_subset, aes(x = x, y = y, fill = mean_gdp)) +
  coord_fixed() +
  scale_fill_viridis_c(name = "Avg GDP", option = "magma", alpha = 1)

p4 <- ggplot() +
  geom_tile(data = netmgr_subset, aes(x = x, y = y, fill = netmgr)) +
  coord_fixed() +
  scale_fill_viridis_c(name = "Net-Migration/1000pp", option = "viridis")

p3 + p4 + plot_layout(ncol = 1)
```

Let's overlap the grid of the two areas. They perfectly match! We can now merge the variables of the two datasets. 

```{r}
library(ggnewscale) # Library to have multiple legends/scales

ggplot() +
  # 1st layer: avg GDP
  geom_tile(data = gdp_subset, aes(x = x, y = y), fill = "white", alpha = 0, color="black", size = 1) +
  coord_fixed() +
  scale_fill_viridis_c(name = "Avg GDP", option = "magma") +
  
  new_scale_fill() + # New scale layer
  
  # 2nd layer: Net-Migration/1000pp
  geom_tile(data = netmgr_subset, aes(x = x, y = y), fill = "white", alpha = 0, color = "red", size = 0.1) +
  coord_fixed() +
  scale_fill_viridis_c(name = "Net-Migration/1000pp", option = "viridis") +
  
  # Legends position
  theme(
    legend.position = "bottom",  # Place both legends below
    legend.box = "horizontal"
  )
```

Spatial join with FNN library: https://rdrr.io/cran/FNN/man/get.knn.html

```{r}
# Fast Nearest Neighbor
library(FNN)

# Extract coordinates
netmgr_coords <- as.matrix(df_netMgr_2000_2019_annual_long[, c("x", "y")])
gdp_coords <- as.matrix(gdp[, c("x", "y")])

# Find nearest neighbor indices
nn_idx <- get.knnx(gdp_coords, netmgr_coords, k = 1)$nn.index[, 1]

# Assign quartiles
df_netMgr_2000_2019_annual_long$gdp_quartile <- gdp$gdp_quartile[nn_idx]
df_netMgr_2000_2019_annual_long$mean_gdp <- gdp$mean_gdp[nn_idx]
```


```{r}
# Subset the area of interest
netmgr_subset1 <- filter_continent(df_netMgr_2000_2019_annual_long, lon_min = 10, lon_max = 15, lat_min = 44, lat_max = 49)

p5 <- ggplot() +
  geom_tile(data = gdp_subset, aes(x = x, y = y, fill = gdp_quartile)) +
  scale_fill_discrete(name = "GDP from original") +
  coord_fixed()

p6 <- ggplot() +
  geom_tile(data = netmgr_subset1, aes(x = x, y = y, fill = gdp_quartile)) +
  scale_fill_discrete(name = "GDP after merge") +
  coord_fixed()

p5 + p6 + plot_layout(ncol = 1)
```

Fancy table with gt: https://gt.rstudio.com/index.html

```{r}
library(gt)

# Summary Statistics
summary_stats <- function(data, variable) {
  q <- quantile(data[[deparse(substitute(variable))]], probs = c(0.25, 0.75), na.rm = TRUE)
  data %>%
    summarize(
      Obs. = n(),
      Mean = mean({{ variable }}, na.rm = TRUE),
      `St. dev.` = sd({{ variable }}, na.rm = TRUE),
      `25th` = q[1],
      `75th` = q[2]
    )
}

# Summary for full sample
summary_migr_full_sample <- summary_stats(df_netMgr_2000_2019_annual_long, netmgr) %>%
  mutate(Group = "Full sample")

# Summary by GDP group
summary_migr_by_group <- df_netMgr_2000_2019_annual_long %>%
  group_by(gdp_quartile) %>%
  # Apply function to each group
  group_modify(~summary_stats(.x, netmgr)) %>%
  rename(Group = gdp_quartile)

# Combine in one table
summary_table_migr <- bind_rows(summary_migr_full_sample, summary_migr_by_group) %>%
  select(Group, Obs., Mean, `St. dev.`, `25th`, `75th`)

# Print nice table
gt(summary_table_migr) %>% 
  fmt_number(columns = "Obs.", use_seps = TRUE, decimals = 0) %>% 
  fmt_number(columns = c(3,4,5,6), decimals = 2) %>% 
  tab_options(table.width = pct(80)) %>% 
  tab_header(title = "Net migration rates")
```


